// Generated by Copilot
/* eslint-disable @typescript-eslint/naming-convention */
import { getTimezoneOffset } from 'date-fns-tz';
import type { MillisecondRange } from '../../types';

/**
 * TimeRangeOffsetter class for converting UTC time ranges to local time ranges
 * based on a specified timezone.
 * 
 * Purpose: Time ranges are defined in UTC (e.g., "12pm every Monday UTC").
 * When fetching data for a specific region, we need to offset these ranges
 * to local time so that "12pm" corresponds to 12pm in the region's timezone
 * (e.g., 12pm ET, 12pm PT, etc.).
 */
export class TimeRangeOffsetter {
  private timezone: string;

  constructor(timezone: string) {
    this.timezone = timezone;
  }


  private getOffsetMs(timestamp: number): number {
    return getTimezoneOffset(this.timezone, new Date(timestamp));
  }

  
  offsetRange(utcRange: MillisecondRange): MillisecondRange {

    const offsetMs = this.getOffsetMs(utcRange.start);
    // this is gonna be a problem if the range crosses a DST boundary ~ doop dee doo for now we ignore that
    // TODO: handle DST boundary crossing
    const localStart = utcRange.start - offsetMs;
    const localEnd = utcRange.end - offsetMs;

    return {
      start: localStart,
      end: localEnd
    };
  }

  offsetRanges(utcRanges: MillisecondRange[]): MillisecondRange[] {
    return utcRanges.map(range => this.offsetRange(range));
  }

  crossesDSTBoundary(range: MillisecondRange): boolean {
    const startOffset = this.getOffsetMs(range.start);
    const endOffset = this.getOffsetMs(range.end);
    return startOffset !== endOffset;
  }

  splitRangeAtDSTBoundary(range: MillisecondRange): MillisecondRange[] {
    // Future implementation: Binary search to find the exact DST transition point
    // For now, just return the original range
    console.warn('DST boundary crossing detected but not yet handled. Range:', range);
    return [range];
  }


  offsetRangesWithDSTHandling(utcRanges: MillisecondRange[]): MillisecondRange[] {
    const result: MillisecondRange[] = [];

    for (const range of utcRanges) {
      if (this.crossesDSTBoundary(range)) {
        // Split and offset each part
        const splitRanges = this.splitRangeAtDSTBoundary(range);
        splitRanges.forEach(splitRange => {
          result.push(this.offsetRange(splitRange));
        });
      } else {
        // Offset the whole range
        result.push(this.offsetRange(range));
      }
    }

    return result;
  }
}
