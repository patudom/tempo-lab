<template>
  <plotly-graph
    :datasets="rezonedDatasets"
    :colors="colors"
    :show-errors="showErrors"
    :data-options="dataOptions"
    :error-bar-styles="errorBarStyles"
    :names="names"
    :layout-options="mergedLayoutOptions"
    :config-options="configOptions"
    @click="(value) => emit('click', value)"
  />
</template>

<script setup lang="ts">
import { computed } from 'vue';
import PlotlyGraph, { type PlotlyGraphProps } from './plotly/PlotlyGraph.vue';
import { mergeFoldTypeLayout } from './plotly/plotly_styles';
import type { FoldType } from '../esri/services/aggregation';
import type { Datum } from 'plotly.js-dist-min';
import { toZonedTime } from 'date-fns-tz';

const browserTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

function cloneTimeFromLocalToBrowser(date: Date, timeZone: string): Date {
  // Get the equivalent time in the target timezone
  const zonedDate = toZonedTime(date, timeZone);
  // Create a new date object in the local timezone with the same components
  return new Date(
    zonedDate.getFullYear(),
    zonedDate.getMonth(),
    zonedDate.getDate(),
    zonedDate.getHours(),
    zonedDate.getMinutes(),
    zonedDate.getSeconds(),
    zonedDate.getMilliseconds()
  );
}

interface FoldedPlotlyGraphProps extends PlotlyGraphProps {
  foldType: FoldType;
  timezones?: string | string[];
}

const props = defineProps<FoldedPlotlyGraphProps>();

// Detailed logging of dataset configuration -- log generated by Sonnet
// props.datasets.forEach((dataset, index) => {
//   const style = 'color: #ff0000; font-weight: bold;';
//   // log the timezones
//   console.log('%cBrowser Timezone: ' + browserTimeZone, style);
//   if (props.timezones) {
//     if (Array.isArray(props.timezones)) {
//       console.log('%cDataset Timezones: ' + props.timezones.join(', '), style);
//     } else {
//       console.log('%cDataset Timezone: ' + props.timezones, style);
//     }
//   } else {
//     console.log('%cNo dataset timezones provided', style);
//   }
//   console.log('%c\n=== Dataset #' + (index + 1) + ' (' + dataset.name + ') ===', style);
  
//   console.log('%cBase Data:', style);
//   console.log('%c  Array Lengths:', style);
//   console.log('%c    x: ' + dataset.x?.length, style);
//   console.log('%c    y: ' + dataset.y?.length, style);
//   console.log('%c  Data Types:', style);
//   console.log('%c    x: ' + (dataset.x?.[0] instanceof Date ? 'Date' : 
//     Array.isArray(dataset.x?.[0]) ? 'Array' : typeof dataset.x?.[0]), style);
//   console.log('%c    y: ' + typeof dataset.y?.[0], style);
//   console.log('%c  Sample Values:', style);
//   console.log('%c    x: ' + JSON.stringify(dataset.x?.slice(0, 2)), style);
//   console.log('%c    y: ' + JSON.stringify(dataset.y?.slice(0, 2)), style);
//   console.log('%c  errorType: ' + (dataset.errorType ?? 'undefined'), style);
  
//   console.log('%cDataset Options:', style);
//   if (dataset.datasetOptions) {
//     console.log('%c  mode: ' + (dataset.datasetOptions.mode ?? 'undefined'), style);
//     console.log('%c  hovertemplate: ' + (dataset.datasetOptions.hovertemplate ?? 'undefined'), style);
    
//     const customdata = dataset.datasetOptions.customdata;
//     if (customdata) {
//       console.log('%c  customdata:', style);
//       console.log('%c    length: ' + customdata.length, style);
//       console.log('%c    type: ' + (
//         customdata[0] instanceof Date ? 'Date' : 
//           Array.isArray(customdata[0]) ? 'Array' : 
//             typeof customdata[0]
//       ), style);
//       console.log('%c    sample: ' + JSON.stringify(customdata.slice(0, 2)), style);
//     } else {
//       console.log('%c  customdata: undefined', style);
//     }
    
//     // Log any other dataset options
//     const otherOptions = { ...dataset.datasetOptions };
//     delete otherOptions.mode;
//     delete otherOptions.hovertemplate;
//     delete otherOptions.customdata;
//     if (Object.keys(otherOptions).length > 0) {
//       console.log('%c  Other options:', style);
//       console.log('%c    ' + JSON.stringify(otherOptions, null, 2).replace(/\\n/g, '\n    '), style);
//     }
//   } else {
//     console.log('%c  No dataset options defined', style);
//   }
// });

const rezonedDatasets = computed(() => {
  // do nothing if the timeseries isn't usind Date object
  if (props.datasets.length === 0 || !(props.datasets[0].x[0] instanceof Date) || !props.timezones) {
    return props.datasets;
  }
  return props.datasets.map((dataset, index) => {
    const timezone = Array.isArray(props.timezones) ? props.timezones[index] : props.timezones;
    const newX = dataset.x.map((x) => {
      if (x instanceof Date) {
        return cloneTimeFromLocalToBrowser(x, timezone ?? browserTimeZone);
      }
      return x;
    });
    return {...dataset, x: newX};
  });
});

const emit = defineEmits<{
  (event: "click", value: {x: Datum, y: number, customdata: unknown}): void;
}>();

// Merge the fold-type specific layout with any custom layout options
const mergedLayoutOptions = computed(() => {
  return mergeFoldTypeLayout(props.foldType, props.layoutOptions);
});
</script>

<style scoped>
</style>
